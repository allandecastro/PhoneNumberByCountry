"use strict";
// Copyright (C) Microsoft Corporation. All rights reserved.
Object.defineProperty(exports, "__esModule", { value: true });
const { validate } = require('jsonschema');
const schema = require('./ManifestSchema.json');
const constants = require("./constants");
const locale_generated_1 = require("./locale.generated");
const diagnosticMessages_generated_1 = require("./diagnosticMessages.generated");
class ManifestSchemaValidator {
    constructor(data) {
        this.parsedJson = data;
        this.errors = [];
    }
    validateManifest() {
        if (!this.parsedJson) {
            return [locale_generated_1.translateA(diagnosticMessages_generated_1.strings.manifest_empty.key, [constants.MANIFEST_INPUT_FILE_NAME])];
        }
        // schema validation
        const result = validate(this.parsedJson, schema);
        if (!result.valid) {
            return result.errors.map(err => err.stack);
        }
        const controlNode = this.parsedJson.manifest.control[0];
        // json schema doesn't support the verification of uniqueness of a specific identifier among an array of objects
        // hence manually validating that properties, values, datasets and type-groups all have unique "name" attributes
        const typeGroupNames = this.validateTypeGroupNodes(controlNode['type-group']);
        this.validatePropertyNodes(controlNode.property, typeGroupNames);
        this.validateDatasetNodes(controlNode['data-set'], typeGroupNames);
        return this.errors;
    }
    validatePropertyNodes(propertyNodes, typeGroupNames, isPropertySet) {
        const key = isPropertySet ? 'property-set' : 'property';
        const propNames = new Set();
        if (propertyNodes) {
            propertyNodes.forEach(prop => {
                if (propNames.has(prop.$.name)) {
                    this.errors.push(locale_generated_1.translateA(diagnosticMessages_generated_1.strings.validation_duplicate_element_name.key, [key, prop.$.name]));
                }
                else {
                    propNames.add(prop.$.name);
                }
                if (prop.$['of-type-group'] && !typeGroupNames.has(prop.$['of-type-group'])) {
                    this.errors.push(locale_generated_1.translateA(diagnosticMessages_generated_1.strings.validation_nonexistent_typegroup.key, [key, prop.$.name]));
                }
                this.validateValueNodes(prop.value, prop.$.name);
            });
        }
    }
    validateDatasetNodes(datasetNodes, typeGroupNames) {
        const datasetNames = new Set();
        if (datasetNodes) {
            datasetNodes.forEach(dataset => {
                if (datasetNames.has(dataset.$.name)) {
                    this.errors.push(locale_generated_1.translateA(diagnosticMessages_generated_1.strings.validation_duplicate_element_name.key, ['data-set', dataset.$.name]));
                }
                else {
                    datasetNames.add(dataset.$.name);
                }
                this.validatePropertyNodes(dataset['property-set'], typeGroupNames, true);
            });
        }
    }
    validateTypeGroupNodes(typeGroups) {
        const typeGroupNames = new Set();
        if (typeGroups) {
            typeGroups.forEach(tg => {
                if (typeGroupNames.has(tg.$.name)) {
                    this.errors.push(locale_generated_1.translateA(diagnosticMessages_generated_1.strings.validation_duplicate_element_name.key, ['type-group', tg.$.name]));
                }
                else {
                    typeGroupNames.add(tg.$.name);
                }
            });
        }
        return typeGroupNames;
    }
    validateValueNodes(values, propName) {
        const enumValueNames = new Set();
        const enumValues = new Set();
        if (values) {
            values.forEach(val => {
                if (enumValueNames.has(val.$.name)) {
                    this.errors.push(locale_generated_1.translateA(diagnosticMessages_generated_1.strings.validation_duplicate_child_element_name.key, ['value', val.$.name, 'property', propName]));
                }
                else {
                    enumValueNames.add(val.$.name);
                }
                if (enumValues.has(val._)) {
                    this.errors.push(locale_generated_1.translateA(diagnosticMessages_generated_1.strings.validation_duplicate_enum_value.key, [val._, 'property', propName]));
                }
                else {
                    enumValues.add(val._);
                }
            });
        }
    }
}
exports.ManifestSchemaValidator = ManifestSchemaValidator;
