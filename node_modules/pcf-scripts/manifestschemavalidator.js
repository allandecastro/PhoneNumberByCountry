"use strict";
// Copyright (C) Microsoft Corporation. All rights reserved.
Object.defineProperty(exports, "__esModule", { value: true });
exports.ManifestSchemaValidator = void 0;
const { validate } = require('jsonschema');
const schema = require('./ManifestSchema.json');
const constants = require("./constants");
const diagnosticMessages_generated_1 = require("./diagnosticMessages.generated");
const featureManager_1 = require("./featureManager");
class ManifestSchemaValidator {
    constructor(data, diag) {
        this.parsedJson = data;
        this.diag = diag;
        this.featureManager = new featureManager_1.FeatureManager();
    }
    validateManifest() {
        if (!this.parsedJson) {
            this.logValidationError(diagnosticMessages_generated_1.strings.manifest_empty, [constants.MANIFEST_INPUT_FILE_NAME]);
            return;
        }
        // schema validation
        const result = validate(this.parsedJson, schema);
        if (!result.valid) {
            result.errors.forEach(err => this.logValidationError(diagnosticMessages_generated_1.strings.manifest_validation_error));
            return;
        }
        const controlNode = this.parsedJson.manifest.control[0];
        // At least one <data-set> node or <property> should be present
        if (!controlNode['data-set'] && !controlNode.property) {
            this.logValidationError(diagnosticMessages_generated_1.strings.validation_noexistent_dataset_property);
        }
        // json schema doesn't support the verification of uniqueness of a specific identifier among an array of objects
        // hence manually validating that properties, values, datasets and type-groups all have unique "name" attributes
        const typeGroupNames = this.validateTypeGroupNodes(controlNode['type-group']);
        this.validatePropertyNodes(controlNode.property, typeGroupNames);
        if (controlNode[constants.SUBSCRIBED_FUNCTIONALITY_SECTION_NODE]) {
            this.validateSubscribedFunctionalities(controlNode);
        }
        this.validateEventNodes(controlNode['event']);
        this.validateCommonEventNodes(controlNode['common-event']);
        this.validateDatasetNodes(controlNode['data-set'], controlNode.property, typeGroupNames);
        this.validateFeatureUsageNodes(controlNode['feature-usage']);
        this.validateConnectorUsageNodes(controlNode['feature-usage']);
        this.validatePropertyDependencyNodes(controlNode['property-dependencies'], controlNode.property);
        this.validateResourceNodes(controlNode['resources'][0]);
    }
    validateSubscribedFunctionalities(controlNode) {
        const functionalities = controlNode[constants.SUBSCRIBED_FUNCTIONALITY_SECTION_NODE][0]['subscribed-functionality'];
        if (functionalities.some(func => func.$.name === constants.SF_SUPPORT_RESETTABLE_PROPS && func.$.value === 'true')
            && controlNode.property
            && !controlNode.property.some(prop => prop.$.resettable && prop.$.resettable === 'true')) {
            this.logValidationError(diagnosticMessages_generated_1.strings.validation_support_resettable_with_no_resettable_props);
        }
        return;
    }
    validateResourceNodes(resources) {
        Object.keys(resources).forEach(resourceType => {
            if (resourceType === 'library' && !this.featureManager.isFeatureEnabled('pcfAllowLibraryResources')) {
                this.logValidationError(diagnosticMessages_generated_1.strings.validation_support_resettable_with_no_resettable_props);
            }
        });
    }
    validatePropertyNodes(propertyNodes, typeGroupNames, isPropertySet) {
        const key = isPropertySet ? 'property-set' : 'property';
        const propNames = new Set();
        if (propertyNodes) {
            propertyNodes.forEach(prop => {
                if (propNames.has(prop.$.name)) {
                    this.logValidationError(diagnosticMessages_generated_1.strings.validation_duplicate_element_name, [key, prop.$.name]);
                }
                else {
                    propNames.add(prop.$.name);
                }
                if (prop.$['of-type-group'] && !typeGroupNames.has(prop.$['of-type-group'])) {
                    this.logValidationError(diagnosticMessages_generated_1.strings.validation_nonexistent_typegroup, [key, prop.$.name]);
                }
                if (prop.$['of-type'] && prop.$['of-type'] === 'Object') {
                    if (!this.featureManager.isFeatureEnabled('pcfObjectType')) {
                        this.logValidationError(diagnosticMessages_generated_1.strings.validation_object_type_error);
                    }
                }
                else if (prop.$['of-type'] && prop.$['of-type'].startsWith('Lookup')) {
                    if (!this.featureManager.isFeatureEnabled('pcfAllowLookup')) {
                        this.logValidationError(diagnosticMessages_generated_1.strings.validation_lookup_type_error);
                    }
                }
                this.validateValueNodes(prop.value, prop.$.name);
            });
        }
    }
    validateEventNodes(eventNodes) {
        if (!this.featureManager.isFeatureEnabled('pcfAllowEvents') && eventNodes) {
            this.logValidationError(diagnosticMessages_generated_1.strings.validation_events_not_allowed);
        }
        if (eventNodes) {
            const eventNames = new Set();
            eventNodes.forEach(event => {
                if (eventNames.has(event.$.name)) {
                    this.logValidationError(diagnosticMessages_generated_1.strings.validation_duplicate_element_name, ['event', event.$.name]);
                }
                else {
                    eventNames.add(event.$.name);
                }
                const reservedCommonEvents = ['OnSelect', 'OnChange'];
                reservedCommonEvents.forEach(commonEvent => {
                    if (event.$.name.toUpperCase() === commonEvent.toUpperCase()) {
                        this.logValidationError(diagnosticMessages_generated_1.strings.validation_event_name_reserved, [event.$.name, commonEvent]);
                    }
                });
            });
        }
    }
    validateCommonEventNodes(commonEventNodes) {
        if (!this.featureManager.isFeatureEnabled('pcfAllowEvents') && commonEventNodes) {
            this.logValidationError(diagnosticMessages_generated_1.strings.validation_events_not_allowed);
        }
        if (commonEventNodes) {
            const commonEventNames = new Set();
            commonEventNodes.forEach(event => {
                if (commonEventNames.has(event.$.name)) {
                    this.logValidationError(diagnosticMessages_generated_1.strings.validation_duplicate_element_name, ['common-event', event.$.name]);
                }
                else {
                    commonEventNames.add(event.$.name);
                }
            });
        }
    }
    validateDatasetNodes(datasetNodes, propertyNodes, typeGroupNames) {
        const datasetNames = new Set();
        if (datasetNodes) {
            datasetNodes.forEach(dataset => {
                if (dataset.$['allow-default-selected-items'] && this.featureManager.isFeatureEnabled('pcfAllowDefaultSelectedItemsForDataSet')) {
                    this.logValidationError(diagnosticMessages_generated_1.strings.validation_invalid_dataset_error, ['allow-default-selected-items']);
                }
                if (datasetNames.has(dataset.$.name)) {
                    this.logValidationError(diagnosticMessages_generated_1.strings.validation_duplicate_element_name, ['data-set', dataset.$.name]);
                }
                else {
                    datasetNames.add(dataset.$.name);
                }
                this.validatePropertyNodes(dataset['property-set'], typeGroupNames, true);
            });
        }
    }
    validateTypeGroupNodes(typeGroups) {
        const typeGroupNames = new Set();
        if (typeGroups) {
            typeGroups.forEach(tg => {
                if (typeGroupNames.has(tg.$.name)) {
                    this.logValidationError(diagnosticMessages_generated_1.strings.validation_duplicate_element_name, ['type-group', tg.$.name]);
                }
                else {
                    typeGroupNames.add(tg.$.name);
                    if (tg.type.includes('Object')) {
                        if (!this.featureManager.isFeatureEnabled('pcfObjectType')) {
                            this.diag.push(diagnosticMessages_generated_1.strings.validation_object_type_error);
                        }
                    }
                }
            });
        }
        return typeGroupNames;
    }
    validateValueNodes(values, propName) {
        const enumValueNames = new Set();
        const enumValues = new Set();
        if (values) {
            values.forEach(val => {
                if (enumValueNames.has(val.$.name)) {
                    this.logValidationError(diagnosticMessages_generated_1.strings.validation_duplicate_child_element_name, ['value', val.$.name, 'property', propName]);
                }
                else {
                    enumValueNames.add(val.$.name);
                }
                if (enumValues.has(val._)) {
                    this.logValidationError(diagnosticMessages_generated_1.strings.validation_duplicate_enum_value, [val._, 'property', propName]);
                }
                else {
                    enumValues.add(val._);
                }
            });
        }
    }
    validateFeatureUsageNodes(featureUsageNode) {
        const usesFeatureNames = new Set();
        if (featureUsageNode && featureUsageNode[0] && featureUsageNode[0]['uses-feature']) {
            featureUsageNode[0]['uses-feature'].forEach(usesFeature => {
                if (usesFeatureNames.has(usesFeature.$.name)) {
                    this.logValidationError(diagnosticMessages_generated_1.strings.validation_duplicate_element_name, ['uses-feature', usesFeature.$.name]);
                }
                else {
                    usesFeatureNames.add(usesFeature.$.name);
                }
            });
        }
        return usesFeatureNames;
    }
    validateConnectorUsageNodes(featureUsageNode) {
        const usesConnectorNames = new Set();
        const usesConnectorIds = new Set();
        if (featureUsageNode && featureUsageNode[0] && featureUsageNode[0]['uses-connector']) {
            if (!this.featureManager.isFeatureEnabled('pcfCanvasDataConnector')) {
                this.diag.push(diagnosticMessages_generated_1.strings.validation_property_dependency_error);
            }
            featureUsageNode[0]['uses-connector'].forEach(useConnector => {
                if (usesConnectorNames.has(useConnector.$.name)) {
                    this.logValidationError(diagnosticMessages_generated_1.strings.validation_duplicate_element_name, ['uses-connector', useConnector.$.name]);
                }
                else {
                    usesConnectorNames.add(useConnector.$.name);
                }
                if (usesConnectorIds.has(useConnector.$.id)) {
                    this.logValidationError(diagnosticMessages_generated_1.strings.validation_duplicate_element_id, ['uses-connector', useConnector.$.id]);
                }
                else {
                    usesConnectorIds.add(useConnector.$.id);
                }
            });
        }
    }
    validatePropertyDependencyNodes(propertyDependencyNodes, propertyNodes) {
        if (propertyDependencyNodes && propertyDependencyNodes[0] && propertyDependencyNodes[0]['property-dependency']) {
            if (!this.featureManager.isFeatureEnabled('pcfPropertyDependencies')) {
                this.logValidationError(diagnosticMessages_generated_1.strings.validation_property_dependency_error);
            }
            const propNames = new Set();
            if (propertyNodes) {
                propertyNodes.forEach(prop => {
                    propNames.add(prop.$.name);
                });
            }
            propertyDependencyNodes[0]['property-dependency'].forEach(propertyDependency => {
                let input = propertyDependency.$['input'];
                let output = propertyDependency.$['output'];
                let requiredFor = propertyDependency.$['required-for'];
                if (!propNames.has(input) || !propNames.has(output)) {
                    this.logValidationError(diagnosticMessages_generated_1.strings.validation_property_dependency_error);
                }
                if (requiredFor !== 'schema') {
                    this.logValidationError(diagnosticMessages_generated_1.strings.validation_property_dependency_error);
                }
            });
        }
    }
    logValidationError(diagError, args) {
        const warningCategoryDiag = { category: 'Warning' };
        const diag = this.featureManager.isFeatureEnabled('treatValidationErrorsAsWarnings')
            ? Object.assign(Object.assign({}, diagError), warningCategoryDiag) : diagError;
        if (args) {
            this.diag.pushA(diag, args);
        }
        else {
            this.diag.push(diag);
        }
    }
}
exports.ManifestSchemaValidator = ManifestSchemaValidator;
